- [x] immediately after write ends, another write is started, which doesn't end until a following cycle, that is the problem
	- problem is that inside of cache, I am not checking if `done` is asserted or not when I start a new operation, so when one is done the next starts right away, that is the problem
- [x] byte offset isn't working why
	- because we aren't even taking it into account while writing that's why!
	- we also aren't considering block offset
- I didn't consider what would happen if the number of write bytes would overflow to the next block, what would I do then?
	- I should just ignore all data that overflows, because that next block might need initializing or evacuating and that would get complex for no reason, that outside should not send more data than could fit, end of story, overflowing data will be ignored `#note0006`
- [ ] incrementing is broken why?
	- I think it is because when I increment I increment the first byte of the read data, but the read data doesn't always have the previous read byte in the lowest byte!, the previous byte might have been in the 3rd byte in the read block/word, so I need to account for the current address
- [ ] how exactly am I ordering read data?
- [ ] remove the number of bytes input, it is too convoluted and leads to unintended behavior, replace with simply which bytes are valid
- [ ] what if the inputter wants to hone in on one specific byte, which byte in the input should they set to valid?
	- given that they know our block size, they will know where in the input block to put their byte