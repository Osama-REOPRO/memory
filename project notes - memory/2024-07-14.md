- [ ] I am still using the addressing method used for writing bytes, that should be removed, the address should be read as is, from the outside we make sure to choose the correct valid bytes
- [ ] why the heck am I still filling it with zeroes every step! that makes no sense!
	- [ ] the reason for filling with zeroes previously is that I had nothing to fill the thing with
	- [ ] I should be pulling the rest of the missing data from upper memory
	- [ ] I try to write to a mem location, I don't get a hit, so I should first pull the rest of the data from up above, the write the new stuff on top
- write procedure
	- first look for empty space in lowest cache, if not found initiate evac procedure
	- when evac done, lookup the missing data up and up until it is found
	- now write that missing block to the lowest level
	- now write the new data on top of that
	- while evacuating, every time you need to fill data you need to fill missing data, you must go look that up until you find it, read it, then write 
- I should be using [[My custom inclusion policy.excalidraw]]
- I should have a task for writing to the the lowest level, that will be used both when writing and when a reading miss occurs
	- this way, it is quite simple when writing we simple run this task and call it a day, when reading, if we miss, we run this task to fill the missing data then just read normally
- how evac works
	- evac L1 to L2
	- find empty space in L2
	- if exists
		- lookup higher levels for that block and fill it with higher data
		- write the new data and set to dirty
	- if not
		- do another evac from L2 to phy
		- lookup higher for space
		- if exists
			- lookup higher levels for that block and fill it with higher data
			- write the new data and set to dirty
		- if not
			- etc.
- how about a universal lookup operation like in the cache
	- whenever any operation stars, be it a read or a write, we do a universal lookup operation which tells us all the information that we need to know before we do anything, it tells us where all the data is located and what is empty and what is not
	- then we move to the execute stage in which we are fully informed as to what is ahead of us, so we can be very efficient and fast, we are not driving in the dark