- [[(decision)]] [[inclusive policy]] or [[exclusive policy]] (**final decision is [[inclusive policy]]**)
	- [[inclusive policy]]
		- this reduces usage of higher caches, it shields them from it
	- [[exclusive policy]]
		- because [[inclusive policy]]'s benefits are more for multi-core systems, while ours is a single core
		- it can have a higher hit rate due to being larger
		- the biggest draw for me though is that it is simpler, no dirty bit and no back invalidation
			- but still I feel like this is quite wasteful
			- especially when memory fills up, hit penalty becomes quite high
	- [[NINE policy]]
		- this is like the [[inclusive policy]] except no [[back invalidation]], which I do like, makes it simpler
	- [[Custom inclusion policy]]
		- I could instead do my own mixed policy, that makes sense for my purposes
		- similar to [[NINE policy]] but with some modifications
		- reads work like in [[inclusive policy]], reading to all caches at once
		- writes on the other hand only write to top level, then get evacuated backward like with [[exclusive policy]], so you minimize memory accesses ([[write back policy]])
		- when you read from an address you simply copy it to all levels beneath it all the way to the processor, remember to also copy the [[dirty bit]] state
		- on conflict: if [[dirty bit]] evacuate, if not [[dirty bit]] just delete
			- this is the advantage of [[inclusive policy]], most of the time it will not be dirty, which means we remove right away without copying to upper level
		- we hit much more often that we miss, so we should be biased towards making hits shorter, potentially at the expense of miss penalty
			- on write hit or miss, write, set to dirty
				- don't look above
			- on read miss, look above
			- on read hit, read and copy to lower caches that missed
			- on conflict, if dirty evacuate, if not dirty delete
			- when we miss, we pay the penalty, make sure we aren't paying any penalty when we hit, otherwise increasing hit rate is meaningless
			- we offload all the penalty to the miss case, then we reduce misses as much as possible
		- remember that evacuations are actually more rare than misses, they happen on conflicts, which can be quite rare
		- no point in writing all the way through all caches, because on evacuation, written data is always dirty, always copied back
	- final decision: [[NINE policy]] for now, because it seems simpler and I already put in the dirty bit, adding [[exclusive policy]] later will be easier this way, because no new bits need to be added
	- maybe implement both? it is a learning experience after all, I might want to benchmark a whole bunch of different combinations and setups, they already seem quite similar in their operation
- [[write operation]] with [[inclusive policy]]
	- TLDR: hit check caches bottom up one at a time until hit, each time you miss you write the data to that cache in whatever address you want, once you hit write the data to the existing address, all written should be set to dirty
	- on way upward, on each miss write data to appropriate location
	- on hit, overwrite existing location, 
		- to avoid duplication
	- after hit, stop [[hit check]]ing upper caches
		- because it is inclusive, once you hit, you know that all caches from there up will have that piece of data
	- before you write to a cache, do a [[hit check]], write to hit location if hit, to avoid duplication, if miss write wherever you want
	- don't write 
	- [[hit check]] lowest cache, then upwards
		- to avoid duplication of data
	- always set [[dirty bit]] to 1 on write operation
- [[suggestion]] we could have a 3 level cache, 2 main levels and a [[victim cache]] that is exclusive of the main levels and fully associative
- [ ] change implementation so that it adheres to [[inclusive policy]]
- [ ] how will [[physical memory]] be treated according to our [[inclusion policy]]?
- [ ] how does [[inclusion policy]] affect/interact with [[write back policy]]?
- [ ] decide on how [[evacuation]] should be handled
- [x] decide on how [[back invalidation]]s should function on an [[evacuation]] in an upper cache (due to [[inclusive policy]])
	- there won't be any back invalidation, that seems like a feature for multi-core systems, which ours isn't
- [[(decision)]] general operation will proceed as follows:	
	- on write hit or miss, write, set to dirty
		- don't look above
	- on read miss, look above
	- on read hit, read and copy to lower caches that missed
	- on conflict, if dirty evacuate, if not dirty delete
- [ ] implement this last decision
- [ ] change all caches so they are controlled by the lower cache