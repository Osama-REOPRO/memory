- [x] data evacuated to wrong address
	- when evacuated from 0 it should land in 0 way in upper cache, instead it goes to 1
	- but you know that isn't actually necessary, which way it lands in really doesn't matter, what matters is that everything else works pretty well actually
	- remember that the choice is random when it comes to which way to go first
- [ ] I want to see data moved up to physical memory and then up to virtual, I want to see that trip upwards
- [x] wrong data is getting evacuated to [[physical memory]], from the wrong way
	- what happens when you read from a multi-way cache, it seems like it might return data from the wrong way
	- when reading we read from hit_N but when writing we write to target_N, could that be the problem
	- yes, target and hit N are actually different in that moment
- [x] data evacuated to the wrong place in [[physical memory]]
	- actually no, it is okay to evacuate first to the last way, that is totally fine
- [x] data fails to get evaluated at first, it gets read but not written to physical for some reason, but then next time it does get written, I don't get why
	- neither the fill with zeroes nor the write evac data is working at first for some reason, it seems like it works every other time!
	- valid bytes were not set at all! they are all 0!
- [x] it seems the cache isn't entering the busy state, even through it should be entering it because it got the mem-op signal, why
- [x] set address is 2 when there is one single set! I think this is the problem
- [x] the [[fully associative]] case is just not well handled at all, I don't even have a bool defined for it like I do with [[direct mapped]]
- [ ] after data is written to physical and it is filled, it begins to behave really weird, data going away then coming back, old data showing up, only the first 2 sets changing values, not sure what is happening