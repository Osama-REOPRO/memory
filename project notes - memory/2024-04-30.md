- [[(code note)]] `note0001`
	- you will notice that that in the random case we replace the lowest bit with the [[use bit (U)]] for that set, so that on each write we switch between odd and even numbered ways, then choose a random way from among them, by replacing the lowest bit we force it to be either odd or even each time
- [ ] implement read hit
- [ ] write tasks for reading and writing
- [x] write conflict check task
- [x] write hit check task
- [x] remove inputs from tasks
- [x] see if vivado has problem with tasks I wrote
	- fixed them
- [ ] change how conflict is detected, if no hit and no empty > conflict
- [ ] explore adding an "evacuation needed" output
- if not dirty it means: I have backup, delete me safely, no need for evacuation
	- meaning all mems before me have a duplicate value so no need for a write back
- there are 2 situations where an evacuation is needed, and they may both occur at once:
	1. if the level below you needs an evacuation, and you don't have space
	2. if a read miss occurred and no space to read new data
	- so the need for an evacuation could come from below or from above or both!
	- when both occur it means that even if we have an empty space, a conflict will end up occurring anyway!
- [ ] remember that a conflict isn't always resolved with an evacuation, you can also resolve it with a delete, depending on whether it is dirty or not
- what do we do when both occur?
	- we know the final value on all of them: it is the read value
	- so where do we evacuate all those old dirty values?
	- shift data upwards as a block, data from lowest cache to lowest non-conflict, then higher to higher etc.
	- when I get an evacuation request, but I myself don't have space, I relay the data to be evacuated to the guy after me
	- a cache which can't store an evacuation request, will let the message pass through itself to the next cache, it will become transparent, get out of the way basically, give the cache below it a direct line of communication to the cache above it, connect the cache below it to the cache above it
	- that is if I have a conflict, or if I don't have a conflict but I need to read so I WILL have a conflict
	- So I need to read the missing data, but, I am waiting for the guy below me to finish 
	- you always evacuate FIRST, if you read first you lose that data! we don't want to lose that data now do we!
	- if I get a miss and the guy behind me needs an evacuation, I know I need to write 2 pieces of data, do I have space for that?
		- my priority is the newly read data, if I have a space that is what I am going to write into it
		- then if I have yet another space, then I will put the evacuated data there
		- if I don't, I will pass that job to the guy after me
		- then if I myself need an evacuation, then I will do the same thing with the guy after me, and so on
	- if the guy before me needs and evacuation and I miss, with conflict
		- once the data is found
		- I first connect the guy behind me to the front because they have precedent
		- Then I take my turn in writing to the front
	- if the guy before me needs and evacuation and I miss, without a conflict
		- I know I have space for the important new data coming from above
		- but do I have the space for the data coming from below (evacuated from below)
		- the solution to this is that, we first write all the data coming from above, then handle the evacuations from below, then those who evacuated write the data from above
	- those who missed without conflict or don't need an evacuation (not dirty, can be deleted right away) immediately in turn write the new incoming data from above, then we look into the evacuations, we go from the bottom to the top, evacuating the most important at the bottom first, then upward, all levels in between giving way, each level after it evacuates reads the new data in place of the evacuated data