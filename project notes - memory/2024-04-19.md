- can the cache function without knowing about the larger system?
	- You see I faced a problem, an interrupted cache does not know that it should stop responding until . . wait . . until what?
- [ ] fix problem which cache interrupted by external hit, it goes back to [[invalid state]], but in that state, it will start all over again if [[i_mem_operation]] is still asserted, that should be prevented
	- I am violating one of my own decisions, which is that the memory should no be responsive to the [[i_mem_operation]] while it is in the [[busy state]], but you see, there is the problem!
	- What I didn't notice was that not only do the cache modules have internal state, but the entire memory system has it's own state, it appears
	- If I don't want to have a larger memory state, then the caches should operate differently
	- In my mind, I should be able to simply chain caches together and they will simply function on their own, no need for external guidance
	- all caches are aware of the outside world in parallel, they all have the same information
	- right now the problem is that they don't know about each other
- [ ] how do caches know their place in the system?
	- their place in the system is determined primarily by their speed, which is a function of their size
	- I could have them know their place in the system by who asserts a hit first
- [[(decision)]] new states
	- these states are switched between asynchronously, the switching happens in separate combinational logic rather than in the state machine itself
	- the things we give names here are the things that take up time, not things that happen instantly, so there won't be a `hit` state, because that is instantaneous
	- `invalid`
		- before first memory operation
		- output meaningless
		- **combinational**: on [[i_mem_operation]]: switch to the `lookup` state
	- `lookup`
		- **combinational**: check if address exists in memory
		- ~~**sync**: read all inputs necessary for the next operation (like [[i_address]] and [[i_write_data]] etc.) into internal registers~~
- [[(decision)]] from the outside, a **cache module** (no the entire system) will have the following states:
- [[(methodology)]] every system will have **external state** and **internal state**
	- **external state** contains the information that the module wants to communicate with the outside world, is one of the module outputs, visible from outside
	- **internal state** governs it's internal operation and controls the **external state**, is an internal register, not visible from outside
- [[(decision)]] we need an internal [[valid bit (V)]] for each cache module and for the larger memory module, independent of the state register, this bit is asserted the first time the cache is read from successfully, that output is held and it becomes valid, and goes back to being valid if it misses in the future
	- this bit is simply there to tell us if this read operation is the first one or not
	- the reason I didn't just add more states is that would cause me to duplicate all the states to have a version for when memory was never read from, effectively the number of state bits is still the same, but we don't have to add too many redundant states and the outside world doesn't see this bit, it only sees the first state of the cache being `invalid`
- [ ] study the **valid start** case
- [ ] study the **invalid start** case
- [[(observation)]] in a single [[read operation]] all internal caches and whole memory module become [[valid state]]
- [[(decision)]] all necessary inputs ([[i_mem_operation]], [[i_mem_write]], [[i_write_data]]) **must be held asserted**, they won't be stored internally
	- to simplify internal structure, no need to store something that doesn't need to change externally
- [[(decision)]] [[i_mem_operation]] must be held asserted during operation, if deasserted, operation will be interrupted
- [[(decision)]] after memory state becomes [[valid state]], outside system must deassert [[i_mem_operation]], then mem switches to [[ready state]], ready to accept a new operation
- [[(decision)]] outside system must wait until memory is in [[ready state]], then it can initiate memory operation by asserting [[i_mem_operation]]
- [[(decision)]] [[o_ack]] qualifies [[o_read_data]]
- [[(decision)]] [[(overriding)]] memory module operation by [[external system]]
	- assert [[i_mem_operation]]
	- wait for [[o_ack]]
	- on [[o_ack]] latch [[o_read_data]] and deassert [[i_mem_operation]]
	- in response to [[i_mem_operation]] deassertion, mem deasserts [[o_ack]]
- [[(decision)]] if [[i_mem_operation]] is deasserted before [[o_ack]] is asserted, operation is interrupted and halted, memory must be able to maintain it's previous state from before [[i_mem_operation]] was asserted, it should seem like nothing happened