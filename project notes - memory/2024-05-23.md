- now with associativity of 2, I would expect the counting up to first go through the first set all the way up, then when full goes back down and fills the other, empty set, and so on
	- this is exactly what happens, but only once
- when both sets are full, weird things start happening
	- I would expect a conflict, and then the set that was used least recently would get evacuated
	- I think the testbench is getting confused by signals I didn't teach it to deal with
	- [x] after evacuation, new value wasn't written, so subsequent operations are reading a 0
	- [ ] after evacuation, value written to wrong N
		- is it because of random generation generating a new value before we get a chance to use the old one?
	- [ ] [[target_N]] is one bit yet I assign a multi-bit value to it when using random generation!!
	- [ ] are we setting [[use_mem]] when we fill with 0s?
	- [ ] the wrong N is getting filled with 0s
	- [ ] introduce a [[hold_N]] var to hold onto randomly generated N
	- [ ] is the problem that we are filling the wrong thing with 0s? and that is causing both the set-use and the mem to be wrong?
	- [ ] it seems that the problem isn't that N is changing when it shouldn't, but rather that it is NOT changing when it SHOULD
	- [ ] experiment with letting the outside the system determine when a new N is generated, perhaps that is better