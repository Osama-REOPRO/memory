- [x] Make small change to design, make the access hierarchical but with the optimization talked about in the video
	- So you only access the cache initially, only access main memory in case of miss, when you do miss, the return could be simultaneous to both cache and output
- [[(decision)]] the state output of a lower cache is input to the cache above it
	- so each cache has information of the cache directly below it
	- so it knows if lower cache has missed and kicks into action
- [[(decision)]] a [[read operation]] will function in the fashion shown [[read operation procedure|here]]
- [[(observation)]] the only information that needs to be communicated by caches to the outside world is the following
	- cache miss to upper cache: so the upper cache starts looking
	- cache hit to all lower caches and to output: so lower caches write the new data and so output becomes valid
	- cache valid 
- when hit, no need to tell upper cache, simply leave it alone, it shouldn't do anything
~~- [[(observation)]] lower caches when they miss, what they see is the upper cache is [[valid state]] for a while (which means it is searching from the moment [[hit state]] entered by lower cache), then it should turn into [[hit state]] or [[miss state]], if turned into [[hit state]], then this lower cache should prepare to latch data when upper cache turns back into [[valid state]]
	- so for a cache to latch data the upper state being in [[valid state]] isn't enough, the upper cache needs to first enter [[hit state]], then~~
- so a [[miss state]] is communicated sequentially to upper caches, while a hit is communicated in parallel to all lower caches
	- a miss climbs up, cache by cache, one at a time
	- then we get a hit, and it is communicated in parallel to all lower caches at the same time and to the output
- [[(methodology)]] the [[i_mem_operation]] will behave like the `cyc` or `stb` signals in [[wishbone]], and the [[o_mem_operation_done]] behaves like the `ack`
- [x] examine case in which we enter [[valid state]], then [[external system]] lowers [[i_mem_operation]] then raises it right away before the memory internally enters [[ready state]]
	- remember that we only lower [[o_mem_operation_done]] when internally we are in [[ready state]], that means that the [[external system]] will mistakenly think that we are indeed done and will read the old data instead of waiting for the new data
	- **Solution:** [[(decision)]] we must lower [[o_mem_operation_done]] immediately when [[i_mem_operation]] lowered, whether done or not, if the external system rises [[i_mem_operation]] too quickly, the will only notice an increased delay, rather than adding more complex states
		- if the external system starts new operation while still in [[valid state]], we simply wait until we reach [[ready state]], then we process the new request
		- [[(reasoning)]] this is yet another reason why the external system must keep the [[i_mem_operation]] asserted throughout the operation
- [[(decision)]] the [[o_mem_operation_done]] signal has the following meanings
	- if asserted and [[i_mem_write]] asserted: [[o_read_data]] is valid for the current [[i_address]]
	- if asserted and [[i_mem_write]] de-asserted: data was written successfully to the current [[i_address]]
	- if deasserted means that [[o_read_data]] is invalid and mem is busy doing the operation requested
- [[(reasoning)]] why the [[o_mem_operation_done]] needs to be both asserted and the de-asserted
	- remember that the main point in this signal is the validate the [[o_read_data]]
	- imagine that the [[external system]] de-asserts [[i_mem_operation]] and reasserts it while cache is still busy, if we didn't deassert [[o_mem_operation_done]] earlier then [[external system]] will thing that we are already done and will read the old value rather than wait for the new one, so for caution, we deassert it as soon as possible to be in the clear of any errors
	- We deassert it to say: don't mind the current output, wait until we tell you that you can read it 
- [[(decision)]] the [[memory module]] becomes [[ready state]] when all caches are [[valid state]]
- [[(decision)]] no [[i_mem_operation]] nor [[i_data_available]] for individual caches
	- you simply pipe the [[memory module]]'s internal [[state]] and that tells us both if we have a [[i_mem_operation]] and notifies the cache when some hit happened elsewhere when the [[memory module]] enters the [[valid state]], so no need for the [[i_data_available]]
	- you also pipe the [[o_state]] of each cache module to the module above it, so it knows when the lower cache has [[miss state]] and kicks into [[lookup state]]
- [[(decision)]] every cache module will have two state inputs ([[system state]] and lower cache state (which is [[o_state]] from the lower cache)) and one state output [[o_state]]
- [[(decision)]] no need for an [[invalid state]]
	- because the output of the memory is only valid while [[o_mem_operation_done]] anyways, so that state is completely unnecessary